[
["index.html", "Notes and some fun with R 1 Introduction", " Notes and some fun with R Lekshmi 2020-08-23 1 Introduction I am Lekshmi Dharmarajan, and recently have found all this new found time during the lockdown season of 2020. With my partner and family all in different parts of the world, what better time to revisit an old friend R. This page contains my notes which I often write down while exploring something new. Since, I have predominantly done things in MATLAB before, the shift to open-source tools is so rewarding. Feel free to contact me if you find something odd or incorrect from my side, this is not surprising as like I said before, these are `just my notes’. "],
["trying-some-ode-solvers-in-r.html", "2 Trying some ODE solvers in R 2.1 diffeqr package 2.2 odeintr package 2.3 sundialr package 2.4 Some remarks", " 2 Trying some ODE solvers in R The last time I had exclusively programmed in R, it was 2014. At that point, I decided to make a shift from R to MATLAB partly because it was the tool that was used in our lab for solving ODEs and numerical analysis and secondly, R had options I was not very interested to use. Now that I have all this new found time after my pandemic defense, what better way to re-educate, and recalibrate myself and check in at what the R world is upto. So promptly I visited the CRAN website and picked out the ones I found interesting to try out. Also see the nice blog comparing different solvers across different languages. As I usually work with ODEs, I checked out a standard non-linear ODE function that I wanted to integrate i.e. the Lokta-Volterra system. I also decided to not use the odeSolve package as I found the others more appealing in terms of model definition and what they interface with. 2.1 diffeqr package What appealed to me is that this package interfaces with the DifferentialEquations.jl in Julia which includes solvers for DDE, ODEs, SDEs, PDEs and many more. Moreover, in comparison to other tools, the julia package has appealing features, of which I would like to highlight event-handling, good efficiency and symbolic calculation of jacobians and autodifferentiation. Also note, that this gives us access to all the solvers in Julia Therefore, an R package that interfaces to the julia package intrgigued me. We begin by setting up the julia interface to R by calling julia_setup function in JuliaCall package. Note that this takes some (considerable) time to run when doing it the first time. # The set up takes time, (a LOT of time when doing the first time.) julia_setup(JULIA_HOME=&quot;/Applications/Julia-1.5.app/Contents/Resources/julia/bin/&quot;) ## Julia version 1.5.0 at location /Applications/Julia-1.5.app/Contents/Resources/julia/bin will be used. ## Loading setup script for JuliaCall... ## Finish loading setup script for JuliaCall. Then, we setup the diffeqr package: diffeqr::diffeq_setup() We begin by defining our ODE system to be evaluated with Julia as ‘f’ and define the initial conditionas and the time span we will integrate the system over. f &lt;- JuliaCall::julia_eval(&quot; function f(du,u,p,t) du[1] = 10.0*(u[2]-u[1]) du[2] = u[1]*(28.0-u[3]) - u[2] du[3] = u[1]*u[2] - (8/3)*u[3] end&quot;) u0 = c(1.0,0.0,0.0) tspan &lt;- list(0.0,100.0) We then solve the ODE. Note that the first time we called the model it also compiles, therefore I store only the second time taken in the second time we solve it. for(i in 1:2){ t_diffeqr&lt;-system.time( {sol = diffeqr::ode.solve(&#39;f&#39;,u0,tspan,reltol=1e-4,abstol=1e-4)} ) } colnames(sol$u)&lt;-c(&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_df=sol$u%&gt;% as_tibble()%&gt;% mutate(time=sol$t) sol_diffeqr_melted=sol_df%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;diffeqr&#39;) 2.2 odeintr package The odeintr package uses the integration engine from Boost and therefore compiles the model in C++. We specify the model in C, compile and integrate it. The nice part it this package allows you to use all the steppers in Boost. I liked the intuitive/ clean way of defining the models and running it. f_c &lt;- &#39; dxdt[0] = 10.0*(x[1]-x[0]); dxdt[1] = x[0]*(28.0-x[2]) - x[1]; dxdt[2] = x[0]*x[1] - (8/3)*x[2]; &#39; # compile model, and pass integration options compile_sys(&quot;lorenz&quot;, f_c,atol = 1e-04, rtol = 1e-04) # Run model t_odeintr=system.time({sol_odeintr = lorenz(u0, 100, 0.001)}) # Results colnames(sol_odeintr)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_odeintr_melted&lt;-sol_odeintr%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;odeintr&#39;) 2.3 sundialr package Finally, the subdialr package that interfaces with CVODE/CVODES (something I am more familiar with). I define a model in R and run it: f_sundials&lt;- function(t,u,p){ du &lt;- vector(mode = &quot;numeric&quot;, length = length(u)) du[1] = 10.0*(u[2]-u[1]) du[2] = u[1]*(28.0-u[3]) - u[2] du[3] = u[1]*u[2] - (8/3)*u[3] du } # run t_cvode=system.time({ sol_cvode&lt;- cvode(seq(0,100,0.01), u0+1e-5, f_sundials,0,reltolerance = 1e-10,abstolerance = 1e-10) }) # colnames(sol_cvode)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_cvode_melted&lt;-sol_cvode%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;sundialr&#39;) and also define one with RCpp: # With RCpp Rcpp::sourceCpp(code = &#39; #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector f_sundials_Rcpp (double t, NumericVector y, NumericVector p){ // Initialize ydot filled with zeros NumericVector dydt(y.length()); // dydt[0] = 10.0*(y[1]-y[0]); dydt[1] = y[0]*(28.0-y[2]) - y[1]; dydt[2] = y[0]*y[1] - (8/3)*y[2]; return dydt; }&#39;) # run t_cvode_cpp=system.time({ sol_cvode_cpp&lt;- cvode(seq(0,100,0.01), u0+1e-10, f_sundials_Rcpp, NaN,reltolerance = 1e-10,abstolerance = 1e-10) }) # colnames(sol_cvode_cpp)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_cvode_cpp_melted&lt;-sol_cvode_cpp%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;sundialr_Rcpp&#39;) 2.4 Some remarks Taking a quick look at the CPU times shows that the diffeqr and odeintr package are faster than the sundialr one. all_sols=bind_rows(sol_cvode_melted,sol_cvode_cpp_melted, sol_odeintr_melted,sol_diffeqr_melted) ggplot(all_sols,aes(x=time,y=value))+ geom_line(aes(col=u))+ scale_color_brewer(palette=&#39;Set1&#39;)+ theme_minimal()+ facet_wrap(~Method) # Time time_df=bind_rows(t_cvode_cpp,t_cvode,t_diffeqr,t_odeintr); time_df&lt;-time_df%&gt;%mutate(package=c(&#39;sundialr_Cpp&#39;, &#39;sundialr&#39;, &#39;diffeqr&#39;, &#39;odeintr&#39;)) kable(time_df) user.self sys.self elapsed user.child sys.child package 0.688 0.011 0.699 0 0 sundialr_Cpp 0.864 0.009 0.873 0 0 sundialr 0.004 0.000 0.005 0 0 diffeqr 0.015 0.002 0.017 0 0 odeintr Finally, ‘deSolve’ also allows us to interface with FORTRAN and C. Since its uses LSODA for solving ODEs. However, I decided against trying this, given the superiority of the methods available in DifferentialEquations.jl. Since a lot of packages are based on ‘deSolve’ I think it deserves a separate and a more serious comparison with the other packages in terms of efficiency, choice of methods available and usability. "],
["wip.html", "3 WIP 3.1 Data 3.2 Model 3.3 Inference", " 3 WIP When I meet other modelers who work in inference, a common suggestion that comes up is to try working with RSTAN and with HMC (Hamilontian Monte Carlo). So it is only fair that I try this out. Let us analyze the COVID counts collected in Switzerland over the past months with an SIR model. I chose this model and data just out of curiosity and as a learning exercise. DISCLAIMER: Note that this model has very simple assumptions, and the data collected has many variables that are not accounted for in the model. Also keep in mind the objective of this exercise is not to try out some inference methods on this data and not draw conclusions or suggestions for possible interventions for COVID. 3.1 Data We will download the covid data from Switzerland from the git repo by openZH. We will specifically look at the data from the canton Basel, because I live here. We plot the data with respect to the first data point. ## date time abbreviation_canton_and_fl ncumul_tested ncumul_conf ncumul_hosp ncumul_ICU ncumul_vent ncumul_released ## 1 2020-02-27 19:17 BS NA 1 NA NA NA NA ## 2 2020-02-28 10:15 BS NA 1 NA NA NA NA ## 3 2020-02-29 15:23 BS NA 1 NA NA NA NA ## 4 2020-03-01 17:29 BS NA 1 NA NA NA NA ## 5 2020-03-02 17:15 BS 235 1 NA NA NA NA ## 6 2020-03-03 17:30 BS NA 3 NA NA NA NA ## ncumul_deceased ## 1 NA ## 2 NA ## 3 NA ## 4 NA ## 5 NA ## 6 NA ## source ## 1 https://www.coronavirus.bs.ch/nm/2020-coronavirus-erster-positiver-fall-in-basel-stadt-zweiter-positiv-getesteter-ausserkantonaler-fall-gd.html ## 2 https://twitter.com/BR_Sprecher/status/1233316679863631873?s=20 ## 3 https://twitter.com/BAG_OFSP_UFSP/status/1233759578241863681?s=20 ## 4 https://www.coronavirus.bs.ch/nm/2020-coronavirus-anzahl-der-getesteten-faelle-und-zwischenstand-kita-riehen-gd.html ## 5 https://www.coronavirus.bs.ch/nm/2020-coronavirus-zwei-neue-positive-faelle-in-basel-stadt-gd.html ## 6 https://twitter.com/BAG_OFSP_UFSP/status/1234880556095213569?s=20 ## ncumul_confirmed_non_resident current_hosp_non_resident current_quarantined_riskareatravel current_quarantined_total ## 1 1 NA NA NA ## 2 1 NA NA NA ## 3 1 NA NA NA ## 4 1 NA NA NA ## 5 3 NA NA NA ## 6 3 NA NA NA ## diff_tested current_hosp_resident ## 1 NA NA ## 2 NA NA ## 3 NA NA ## 4 NA NA ## 5 NA NA ## 6 NA NA ## Don&#39;t know how to automatically pick scale for object of type difftime. Defaulting to continuous. Rather than plotting the cumulative cases, we may be interested to look at the confirmed cases on days we obtained data. To visualize the trend, we also fit a generalized additive model model using an assumption that the likelihood of the data can be described with a Poisson distribution (with a log link function). ## Don&#39;t know how to automatically pick scale for object of type difftime. Defaulting to continuous. 3.2 Model 3.3 Inference "]
]
