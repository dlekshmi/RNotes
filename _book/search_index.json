[
["index.html", "Notes and some fun with R 1 Introduction", " Notes and some fun with R Lekshmi 2020-07-18 1 Introduction I am Lekshmi Dharmarajan, and recently have found all this new found time during the lockdown season of 2020. With my partner and family all in different parts of thw world, what better time to revisit an old friend R. This page comtains my notes which I often write down while exploring something new. Since, I have predominantly done things in MATLAB before, the shift to open-source tools is so rewarding. Feel free to contact me if you find something odd or incorrect from my side, this is not surprising as like I said before, these are `just my notes’. "],
["trying-some-ode-solvers-in-r.html", "2 Trying some ODE solvers in R 2.1 diffeqr package 2.2 odeintr package 2.3 sundialr package 2.4 Some remarks", " 2 Trying some ODE solvers in R source(&#39;./setup.R&#39;) ## Using checkpoint directory /Users/dlekshmi/.checkpoint/2020-07-17/lib/x86_64-apple-darwin15.6.0/3.6.0 The last time I had exclusively programmed in R, it was 2014. At that point, I decided to make a shift from R to MATLAB partly because it was the tool that was used in our lab for solving ODEs and numerical analysis and secondly, R had options I was not very interested to use. Now that I have all this new found time after my pandemic defense, what better way to re-educate, and recalibrate myself and check in at what the R world is upto. So promptly I visited the CRAN website and picked out the ones I found interesting to try out. Also see the nice blog comparing different solvers across different languages. As I usually work with ODEs, I checked out a standard non-linear ODE function that I wanted to integrate i.e. the Lokta-Volterra system. I also decided to not use the odeSolve package as I found the others more appealing in terms of model definition and what they interface with. 2.1 diffeqr package What appealed to me is that this package interfaces with the DifferentialEquations.jl in Julia which includes solvers for DDE, ODEs, SDEs, PDEs and many more. Moreover, in comparison to other tools, the julia package has appealing features, of which I would like to highlight event-handling, good efficiency and symbolic calculation of jacobians and autodifferentiation. Also note, that this gives us access to all the solvers in Julia Therefore, an R package that interfaces to the julia package intrgigued me. We begin by setting up the julia interface to R by calling julia_setup function in JuliaCall package. Note that this takes some (considerable) time to run when doing it the first time. # The set up takes time, (a LOT of time when doing the first stime.) julia_setup(JULIA_HOME=&quot;/Applications/Julia-1.2.app/Contents/Resources/julia/bin&quot;) Then, we setup the diffeqr package: diffeqr::diffeq_setup() We begin by defining our ODE system to be evaluated with Julia as ‘f’ and define the initial conditionas and the time span we will integrate the system over. f &lt;- JuliaCall::julia_eval(&quot; function f(du,u,p,t) du[1] = 10.0*(u[2]-u[1]) du[2] = u[1]*(28.0-u[3]) - u[2] du[3] = u[1]*u[2] - (8/3)*u[3] end&quot;) u0 = c(1.0,0.0,0.0) tspan &lt;- list(0.0,100.0) We then solve the ODE. Note that the first time we called the model it also compiles, therefore I store only the second time taken in the second time we solve it. for(i in 1:2){ t_diffeqr&lt;-system.time( {sol = diffeqr::ode.solve(&#39;f&#39;,u0,tspan,reltol=1e-4,abstol=1e-4)} ) } colnames(sol$u)&lt;-c(&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_df=sol$u%&gt;% as_tibble()%&gt;% mutate(time=sol$t) sol_diffeqr_melted=sol_df%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;diffeqr&#39;) 2.2 odeintr package The odeintr package uses the integration engine from Boost and therefore compiles the model in C++. We specify the model in C, compile and integrate it. The nice part it this package allows you to use all the steppers in Boost. I liked the intuitive/ clean way of defining the models and running it. f_c &lt;- &#39; dxdt[0] = 10.0*(x[1]-x[0]); dxdt[1] = x[0]*(28.0-x[2]) - x[1]; dxdt[2] = x[0]*x[1] - (8/3)*x[2]; &#39; # compile model, and pass integration options compile_sys(&quot;lorenz&quot;, f_c,atol = 1e-04, rtol = 1e-04) # Run model t_odeintr=system.time({sol_odeintr = lorenz(u0, 100, 0.001)}) # Results colnames(sol_odeintr)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_odeintr_melted&lt;-sol_odeintr%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;odeintr&#39;) 2.3 sundialr package Finally, the subdialr package that interfaces with CVODE/CVODES (something I am more familiar with). I define a model in R and run it: f_sundials&lt;- function(t,u,p){ du &lt;- vector(mode = &quot;numeric&quot;, length = length(u)) du[1] = 10.0*(u[2]-u[1]) du[2] = u[1]*(28.0-u[3]) - u[2] du[3] = u[1]*u[2] - (8/3)*u[3] du } # run t_cvode=system.time({ sol_cvode&lt;- cvode(seq(0,100,0.2), u0+1e-10, f_sundials,0,reltolerance = 1e-4,abstolerance = 1e-4) }) # colnames(sol_cvode)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_cvode_melted&lt;-sol_cvode%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;sundialr&#39;) and also define one with RCpp: # With RCpp Rcpp::sourceCpp(code = &#39; #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector f_sundials_Rcpp (double t, NumericVector y, NumericVector p){ // Initialize ydot filled with zeros NumericVector dydt(y.length()); // dydt[0] = 10.0*(y[1]-y[0]); dydt[1] = y[0]*(28.0-y[2]) - y[1]; dydt[2] = y[0]*y[1] - (8/3)*y[2]; return dydt; }&#39;) # run t_cvode_cpp=system.time({ sol_cvode_cpp&lt;- cvode(seq(0,100,0.2), u0+1e-10, f_sundials_Rcpp, NaN,reltolerance = 1e-4,abstolerance = 1e-4) }) # colnames(sol_cvode_cpp)&lt;-c(&#39;time&#39;,&#39;u1&#39;,&#39;u2&#39;,&#39;u3&#39;) sol_cvode_cpp_melted&lt;-sol_cvode_cpp%&gt;% as_tibble()%&gt;% gather(key=u,value=&#39;value&#39;,-time)%&gt;% mutate(Method=&#39;sundialr_Rcpp&#39;) 2.4 Some remarks Taking a quick look at the CPU times shows that the diffeqr and odeintr package are faster than the sundialr one. all_sols=bind_rows(sol_cvode_melted,sol_cvode_cpp_melted, sol_odeintr_melted,sol_diffeqr_melted) ggplot(all_sols,aes(x=time,y=value))+ geom_line(aes(col=u))+ scale_color_brewer(palette=&#39;Set1&#39;)+ theme_minimal()+ facet_wrap(~Method) # Time time_df=bind_rows(t_cvode_cpp,t_cvode,t_diffeqr,t_odeintr); time_df&lt;-time_df%&gt;%mutate(package=c(&#39;sundialr_Cpp&#39;, &#39;sundialr&#39;, &#39;diffeqr&#39;, &#39;odeintr&#39;)) kable(time_df) user.self sys.self elapsed user.child sys.child package 0.114 0.003 0.124 0.000 0.000 sundialr_Cpp 0.330 0.028 0.398 0.000 0.000 sundialr 0.011 0.014 0.211 0.015 0.112 diffeqr 0.017 0.001 0.019 0.000 0.000 odeintr Finally, ‘deSolve’ also allows us to interface with FORTRAN and C. Since its uses LSODA for solving ODEs. However, I decided against trying this, given the superiority of the methods available in DifferentialEquations.jl. Since a lot of packages are based on ‘deSolve’ I think it deserves a separate and a more serious comparison with the other packages in terms of efficiency, choice of methods available and usability. "]
]
